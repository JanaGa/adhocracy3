/// <reference path="../../../lib/DefinitelyTyped/requirejs/require.d.ts"/>
/// <reference path="../../../lib/DefinitelyTyped/jquery/jquery.d.ts"/>
/// <reference path="../../../lib/DefinitelyTyped/angularjs/angular.d.ts"/>

import Types = require("../Types");
import AdhConfig = require("./Config");


// The Web Sockets Service

// This module provides a callback-based API to the consumer modules
// for keeping up to date with relevant changes on the server side.
// The network protocol is specified in ./docs/source/websockets.rst.


export interface Type {
    // Send subscribe message to server.  If the response is
    // 'redundant', an exception is thrown asynchronously.
    //
    // The message passed to the callback will contain the path passed
    // to the subscribe function earlier, plus additional information
    // like "child_modified" (see rest api documentation).
    //
    // This function is a rough equivalent to $.on(), but it only
    // allows to register one handler at a time.  (Should we ever need
    // more than one concurrent handlers, we should think about a
    // better way to unsubscribe them than jquery could come up with.)
    subscribe: (path: string, callback: (event: ServerEvent) => void) => string;

    // Send unsubscribe message to server.  If the response is
    // 'redundant', an exception is thrown asynchronously.
    //
    // Roughly equivalent to $.off() (see comment above).
    unsubscribe: (path: string, id: string) => void;
}

export interface ServerEvent {
    event?: string;
    resource?: string;
    child?: string;
    version?: string;
}


// internal rest-api types

interface Request {
    action: string;
    resource: string;
}

interface ResponseOk {
    status?: string;
    action?: string;
    resource?: string;
}

interface ResponseError {
    error?: string;
    details?: string;
}

interface ServerMessage extends ResponseOk, ResponseError, ServerEvent {};


/**
 * A Subscription instance is a dictionary of dictionaries.  The first
 * maps a resource to all its subscribed callbacks; the second maps
 * callback identifiers to actual callbacks.  Callback identifiers are
 * generated by .add during addition and used by .del in order to
 * identify the deletee.  Method .notify takes a resource and calls
 * all subscribed callbacks.  Method .forAll calls a given function on
 * all callbacks.
 */
class Subscriptions {
    constructor(private _createCallbackId: () => string) {
        return;
    }

    private _dict: {
        [name: string]: {
            [id: string]: (event: ServerEvent) => void
        }
    } = {};

    public notify = (event: ServerEvent): void => {
        var _self = this;

        if (_self._dict.hasOwnProperty(event.resource)) {
            var cbs = _self._dict[event.resource];
            for (var cbid in cbs) {
                if (cbs.hasOwnProperty(cbid)) {
                    cbs[cbid](event);
                }
            }
        } else {
            throw "WS: got notification of event that i haven't subscribed!";
        }
    };

    public forAll = (cmd: (resource: string, id: string, callback: (event: ServerEvent) => void) => void): void => {
        var _self = this;
        var _dict = _self._dict;

        for (var resource in _dict) {
            if (_dict.hasOwnProperty(resource)) {
                for (var id in _dict[resource]) {
                    if (_dict[resource].hasOwnProperty(id)) {
                        cmd(resource, id, _dict[resource][id]);
                    }
                }
            }
        }
    };

    public add = (resource: string, callback: (event: ServerEvent) => void, id?: string): string => {
        var _self = this;
        var _dict = _self._dict;

        if (typeof id === "undefined") {
            id = _self._createCallbackId();
        }

        if (!_dict.hasOwnProperty(resource)) {
            _dict[resource] = {};
        }

        if (_dict[resource].hasOwnProperty(id)) {
            throw "WS: Subscription().add was passed an already-added id!";
        }

        _dict[resource][id] = callback;
        return id;
    };

    public del = (resource: string, id: string): void => {
        var _self = this;
        var _dict = _self._dict;

        delete _dict[resource][id];
        if (_dict[resource] === {}) {
            delete _dict[resource];
        }
    };
}


export var factory = (adhConfig: AdhConfig.Type) : Type => {
    "use strict";

    // the socket handle
    var _ws;

    // a distionary of all callbacks, stored under their
    // resp. resources.
    var _subscriptions: Subscriptions;

    // same type as _subscriptions, but these are still waiting for
    // being sent over the wire.  this is necessary because when _ws
    // is initialized and the adhWS handle returned to the consumer,
    // the consumer may start subscribing to stuff, but the web socket
    // is not in connected state yet.
    var _pendingSubscriptions: Subscriptions;

    // request queue.  we append all requests to the end of this list,
    // and pop them from the beginning as the responses come in.
    // rationale: "ok" responses contain a copy of the request data,
    // but "error" responses do not (the request may have been broken
    // json and not contain any valid data).  so it is necessary to
    // rely on the responses coming back in the same order in which
    // the frontend send the requests.
    var _requests: Request[] = [];


    // function declarations
    var subscribe: (path: string, callback: (event: ServerEvent) => void) => string;
    var unsubscribe: (path: string, id: string) => void;
    var sendRequest: (req: Request) => void;

    var onmessage: (event: any) => void;
    var onerror: (event: any) => void;
    var onopen: (event: any) => void;
    var onclose: (event: any) => void;

    var open: () => any;


    // register a new callback asynchronously (to _subscriptions if
    // connected; to _pendingSubscription otherwise).  if one is
    // already registered, crash.
    subscribe = (
        path: string,
        callback: (event: ServerEvent) => void
    ) : string => {
        if (_ws.readyState === _ws.OPEN) {
            sendRequest({action: "subscribe", resource: path});
            return _subscriptions.add(path, callback);
        } else {
            return _pendingSubscriptions.add(path, callback);
        }
    };

    // unregister callback.  if it is not registered, crash.
    unsubscribe = (
        path: string,
        id: string
    ) : void => {
        if (!(_subscriptions.hasOwnProperty(path) ||
              _pendingSubscriptions.hasOwnProperty(path))) {
            throw "WS: unsubscribe: no subscription for " + path + "!";
        } else {
            if (_ws.readyState === _ws.OPEN) {
                sendRequest({action: "unsubscribe", resource: path});
            }

            // the case that _ws is not OPEN is silently ignored: the
            // server is expected to have forgotten anyway.

            _subscriptions.del(path, id);
            _pendingSubscriptions.del(path, id);
        }
    };

    // Send Request object (subscribe or unsubscribe); push it to
    // _requests; do some exception handling and logging.
    sendRequest = (
        req: Request
    ) : void => {
        var reqString: string = JSON.stringify(req);
        console.log("WS: sending " + reqString);  // FIXME: remove this when it is tested.

        if (_ws.readyState !== _ws.OPEN) {
            throw "WS: attempt to write to non-OPEN websocket!";
        } else {
            _ws.send(reqString);
            _requests.push(req);
        }
    };

    // event handlers and open
    onmessage = (event) : void => {
        var msg: ServerMessage = event.data;
        console.log("WS: onmessage:"); console.log(msg);  // FIXME: remove this when it is tested.

        // ServerEvent: something happened in the backend data!
        if (msg.hasOwnProperty("event")) {
            _subscriptions.notify(msg);
        } else {
            // if it is not an event, remove the matching request from
            // the queue and check for errors (server or client, user
            // or internal).
            var req: Request = _requests.shift();

            // ResponseOk: request successfully processed!
            if (msg.hasOwnProperty("status")) {
                var checkCompare = (req: Request, resp: ResponseOk) => {
                    if (req.action !== resp.action || req.resource !== resp.resource) {
                        throw ("WS: onmessage: response does not match request!\n"
                            + req.toString() + "\n"
                            + resp.toString());
                    }
                };

                var checkRedundant = (resp: ResponseOk) => {
                    throw ("WS: onmessage: received 'redundant' response.  this should not happen!\n"
                        + resp.toString());
                };

                switch (msg.status) {
                case "ok":
                    checkCompare(req, msg);
                    break;

                case "redundant":
                    checkCompare(req, msg);
                    checkRedundant(msg);
                    break;
                }
            }

            // ResponseError: request failed!
            if (msg.hasOwnProperty("error")) {
                switch (msg.error) {
                case "unknown_action":
                case "unknown_resource":
                case "malformed_message":
                case "invalid_json":
                case "subscribe_not_supported":
                case "internal_error":
                    throw ("WS: onmessage: received error message.\n"
                        + msg.error + "\n"
                        + req.toString() + "\n"
                        + msg.toString());

                default:
                    throw ("WS: onmessage: received **unknown** error message.  this should not happen!\n"
                        + msg.error + "\n"
                        + req.toString() + "\n"
                        + msg.toString());
                }
            }
        }
    };

    onerror = (event) => {
        console.log("WS: error!");
        console.log(event);
        throw "WS: error!";
    };

    onopen = (event) => {
        _pendingSubscriptions.forAll((path, id, callback) => {
            sendRequest({action: "subscribe", resource: path});
            _subscriptions.add(path, callback, id);
            _pendingSubscriptions.del(path, id);
        });
    };

    onclose = (event) => {
        // _ws = open();

        console.log("WS: close!  (see source code for things to fix here.)");
        console.log(event);

        // FIXME: this is bad because it invalidates all previous
        // subscriptions, but adhWS is not aware of that.
        //
        // if you fix this, also check unsubscribe (currently if
        // called in unconnected state, it clears out _subscriptions
        // and _pendingSubscriptions and just assumes the server has
        // unsusbcribed everything already.

        throw "WS: close!";
    };

    open = () => {
        var _ws = new WebSocket(adhConfig.wsuri);

        _ws.onmessage = onmessage;
        _ws.onerror = onerror;
        _ws.onopen = onopen;
        _ws.onclose = onclose;

        var createCallbackId = (() => {
            var x : number = 0;
            return () => { return (x++).toString(); };
        })();

        _subscriptions = new Subscriptions(createCallbackId);
        _pendingSubscriptions = new Subscriptions(createCallbackId);

        return _ws;
    };

    // (main)
    _ws = open();

    return {
        subscribe: subscribe,
        unsubscribe: unsubscribe
    };
};



//////////////////////////////////////////////////////////////////////
// test widget

/**
 * FIXME: this should go to some test module.
 *
 * Take a maximum delay time, an array of arguments and a function.
 * Generate random delays for each and calls the function
 * asynchronously (out of order) on each element of the array.  Ignore
 * return values of f.
 */
var trickle = <T>($timeout: ng.ITimeoutService, maxdelay: number, xs: T[], f: (T) => void): void => {
    xs.map((x) => $timeout(() => f(x), Math.random() * maxdelay, true));
};


interface WebSocketTestScope extends ng.IScope {
    messages: ServerMessage[];
    rawPaths: string;
}


/**
 * A simple test widget that dumps all relevant messages coming in
 * over the web socket to <pre> elements in the UI.
 */
export class WebSocketTest {

    public createDirective = ($timeout: ng.ITimeoutService, adhConfig: AdhConfig.Type, adhWS: Type) : ng.IDirective => {
        var _self = this;

        return {
            restrict: "E",
            templateUrl: adhConfig.templatePath + "/Widgets/WebSocketTest.html",
            scope: {
                rawPaths: "@paths"
            },
            transclude: true,
            controller: ["$scope", "$timeout", ($scope: WebSocketTestScope) => {
                $scope.messages = [];
                var paths = JSON.parse($scope.rawPaths);
                paths.map((path) => {
                    adhWS.subscribe(path, (serverEvent) => $scope.messages.push(serverEvent));
                });

                // FIXME: just for debugging, we send some ourselves.
                trickle($timeout, 5000, paths, (path) => $scope.messages.push({ "event": "modified", "resource": path }));
                trickle($timeout, 10000, paths, (path) => $scope.messages.push({ "event": "modified", "resource": path }));
            }]
        };
    };
}


/**
 * A button that is inactive as long as no changes are reported.  If a
 * change message is recieved via the web socket, the button is
 * activated and changes its appearance.  Incoming change messages are
 * collected and can be used in the rendering of the button (e.g. for
 * the message "there are N changes").  On button click, an angular
 * event is sent to all registered scopes.
 */

/*
export class WebSocketTrackerButton {
    ...
}

*/
